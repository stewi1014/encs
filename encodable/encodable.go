// Package encodable provides low-level methods for seralising golang data structures.
// It aims to be fast, modular and comprehensive, valuing runtime speed over creation overhead.
//
// Encodable is the interface implemented by encoders, while Source is the interface implemented by Encodable generators.
package encodable

// I intend to keep a curated list of important notes to keep in mind while developing this part of encs here.
//
// https://golang.org/pkg/unsafe/#Pointer; "Note that the pointer must point into an allocated object, so it may not be nil".
// Every instance of unsafe.Pointer that exists must always point towards a valid object because apparently it can cause the garbage collector to panic.
// Except, it doesn't. nil values of unsafe.Pointer are used in the standard libraries. I'm unsure what to make of this, but figure it's best to avoid nil pointers.
// checkPtr can be used to create a helpful panic if an unsafe.Pointer value is nil.
//
// Recursion detection relies on the same pointer being attempted to Encode from. Encodables may allocate and pass whatever pointers
// they want to element Decoders when decoding, but they may not do so during encoding. If and Encodable allocates a new object and passes it to its element encodables,
// then it must implement its own recursion checks; the Recursive Encodable will not work.

import (
	"io"
	"reflect"
	"unsafe"
)

const (
	// StructTag is the boolean struct tag that when applied to a struct, will force the field's inclusion or exclusion from encoding.
	// srvconv.ParseBool() is used for parsing the tag value; it accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.
	StructTag = "encs"
)

// Encodable is an Encoder and Decoder for a specific type.
// The aim is to provide a framework that clearly separates the encoding logic for a given type, both from other types, and from their interactions at runtime.
//
// Encodables are not assumed to be thread safe.
// Use NewConcurrent or higher level methods if concurrency is needed.
//
// -
//
// Encodables are allowed to assume certain characteristics inside their methods, see Source for details on how recursion is handled:
//
// - Encode() and Decode() will not be called concurrently.
//
// - Calling NewEncodable() on the provided Source will not result in infinite recursion, namely when given the same type as the calling Encodable.
//
// - Calling Encode() or Decode() on an Encodable that was generated by the provided Source will not result in nested calls to the calling Encodable.
//
// - Calling Encode() on an Encodable that was generated by the provided Source will not result in infinite recursion unless the passed pointer is to a copied object.
//
// - Calling Decode() on an Encodable that was generated by the provided Source will not result in infinite recursion.
//
// - Reading from the io.Reader provided to Decode will return the same data, in the same order as was written to the io.Writer in Encode.
//
// -
//
// In order to provide these assumptions, Encodables must:
//
// - Only create Encodables using the provided source, with the exception of Encodables for types that cannot possibly hold a reference of any kind.
// i.e. An int encodable could create its own int64 Encodable to delegate to, but a struct Encodable may not create its own Encodables for fields.
//
// - Never copy the value they're given when passing it to element Encodables unless the value being copied cannot possibly be referenced by anything else; it's unaddressable.
// Examples include the values directly inside an interface or map, and values inside a reflect.Value when CanAddr() is false.
//
// - Always pass the same Source they were given to element Encodables.
//
// - Never pass Encodables to other Encodables; each Encodable must make its own element Encodables.
//
// - Always read the same amount of data as was written, even if the data is useless. Don't leave garbage in the buffer for the next encode.
//
// -
//
// Encodables return two kinds of error.
// See encs/encio/error.go for error types.
//
// The pointers passed to Encode and Decode must be pointers to an allocated instance of the Encodable's type, accessible by Type().
// See https://golang.org/pkg/unsafe/#Pointer; "Note that the pointer must point into an allocated object, so it may not be nil".
type Encodable interface {
	// Type returns the type that the Encodable encodes.
	// It is thread safe.
	Type() reflect.Type

	// Size returns the maximum encoded size of the Encodable.
	// If Size returns <0, size is undefined.
	// It is thread safe.
	Size() int

	// Encode encodes the object at ptr, writing to w.
	// If Size() returns >1, Encode will write at most Size() bytes.
	// It panics if ptr is nil.
	Encode(ptr unsafe.Pointer, w io.Writer) error

	// Decode decodes from r into the object at ptr.
	// Decode will completely read what Encode wrote and only what Encode wrote; no more, no less.
	// It panics if ptr is nil.
	Decode(ptr unsafe.Pointer, r io.Reader) error
}
